<!DOCTYPE html>
<html>
<head>
    <title>Geospatial Data Converter - A Simple Coordinate Transformation Tool</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <style>
        body {
            font-family: "MS Sans Serif", sans-serif;
            background: linear-gradient(45deg, #008080, #00CED1, #20B2AA);
            background-attachment: fixed;
            color: #000;
            margin: 0;
            padding: 0;
            font-size: 12px;
        }
        .header {
            background: linear-gradient(to bottom, #C0C0C0, #808080);
            border: 2px outset #C0C0C0;
            color: #000;
            padding: 15px;
            text-align: center;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .header h1 {
            margin: 0;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 1px 1px 1px #FFF;
        }
        .header p {
            margin: 5px 0 0;
            font-size: 14px;
            font-style: italic;
        }
        .container {
            width: 95%;
            max-width: 1200px;
            margin: 20px auto;
            background: #C0C0C0;
            border: 2px outset #C0C0C0;
            box-shadow: 4px 4px 8px rgba(0,0,0,0.5);
        }
        .converter-grid {
            display: flex;
        }
        .converter-panel {
            width: 50%;
            padding: 15px;
            background: #C0C0C0;
        }
        .converter-panel:first-child {
            border-right: 2px inset #C0C0C0;
        }
        .panel-title {
            font-size: 14px;
            font-weight: bold;
            color: #000080;
            margin-bottom: 10px;
            text-decoration: underline;
        }
        .title-bar {
            background: linear-gradient(to right, #000080, #0000FF);
            color: #FFF;
            padding: 8px 15px;
            font-weight: bold;
            font-size: 16px;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
        }
        label {
            display: block;
            font-weight: bold;
            margin-bottom: 3px;
            color: #000;
            font-size: 11px;
        }
        select, textarea {
            width: 100%;
            padding: 2px;
            border: 2px inset #C0C0C0;
            font-size: 11px;
            font-family: "MS Sans Serif", sans-serif;
            box-sizing: border-box;
            background: #FFF;
        }
        textarea {
            font-family: "Courier New", monospace;
            resize: vertical;
            min-height: 120px;
            background: #FFF;
        }
        .action-button {
            background: linear-gradient(to bottom, #C0C0C0, #808080);
            color: #000;
            font-weight: bold;
            font-size: 11px;
            border: 2px outset #C0C0C0;
            padding: 4px 12px;
            cursor: pointer;
            margin-top: 8px;
            margin-right: 5px;
            font-family: "MS Sans Serif", sans-serif;
        }
        .action-button:hover {
            background: linear-gradient(to bottom, #E0E0E0, #A0A0A0);
        }
        .action-button:active {
            border: 2px inset #C0C0C0;
        }
        .action-button:disabled {
            color: #808080;
            cursor: default;
            background: #C0C0C0;
        }
        .output-actions .action-button {
            background: linear-gradient(to bottom, #90EE90, #32CD32);
            color: #000;
        }
        .output-actions .action-button:hover {
            background: linear-gradient(to bottom, #98FB98, #228B22);
        }
        .status-bar {
            text-align: center;
            padding: 8px;
            margin: 15px auto;
            width: 90%;
            max-width: 1150px;
            border: 2px inset #C0C0C0;
            font-weight: bold;
            font-size: 11px;
            background: #C0C0C0;
        }
        .status-success {
            background: #90EE90;
            color: #006400;
        }
        .status-error {
            background: #FFB6C1;
            color: #8B0000;
        }
        .footer {
            text-align: center;
            padding: 15px;
            color: #000;
            font-size: 10px;
            background: rgba(192, 192, 192, 0.8);
            border: 1px solid #808080;
            margin: 20px auto;
            width: 90%;
            max-width: 1150px;
        }
        .blink {
            animation: blink 1s linear infinite;
        }
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
    </style>
</head>
<body>
    
    <div class="header">
        <h1>üåç Geospatial Data Converter üåç</h1>
        <p>A fast and simple tool for converting between common coordinate formats.</p>
    </div>

    <div class="container">
        <div class="title-bar">
            ‚ö° Conversion Tool ‚ö°
        </div>
        <div class="converter-grid">
            <div class="converter-panel">
                <div class="panel-title">üì• Input Data</div>
                
                <label for="inputFormat">Input Format:</label>
                <select id="inputFormat" onchange="updateInputPlaceholder()">
                    <option value="geojson">GeoJSON / Feature / FeatureCollection</option>
                    <option value="wkt">WKT (Well-Known Text)</option>
                    <option value="latlon">Lat/Lon Coordinates</option>
                </select>
                <br><br>
                
                <label for="inputData">Paste Your Data Here:</label>
                <textarea id="inputData" rows="8" placeholder="Enter your WKT data here..."></textarea>
                <br><br>
                
                <button class="action-button" onclick="convertData()">üîÑ Convert ‚Üí</button>
            </div>
            
            <div class="converter-panel">
                <div class="panel-title">üì§ Output Results</div>
                
                <label for="outputFormat">Output Format:</label>
                <select id="outputFormat">
                    <option value="wkt">WKT (Well-Known Text)</option>
                    <option value="latlon">Lat/Lon Coordinates</option>
                    <option value="geojson">GeoJSON / Feature / FeatureCollection</option>
                </select>
                <br><br>
                
                <label for="outputData">Converted Data:</label>
                <textarea id="outputData" rows="8" readonly placeholder="Converted data will appear here..."></textarea>
                <br><br>
                
                <div class="output-actions">
                    <button class="action-button" onclick="copyResults()">üìã Copy to Clipboard</button>
                    <button class="action-button" id="downloadButton" onclick="downloadFile()" disabled>üíæ Download File</button>
                </div>
            </div>
        </div>
    </div>

    <div id="statusContainer" style="display: none;">
        <div id="statusMessage" class="status-bar"></div>
    </div>

    <div class="footer">
        <p>A lightweight, in-browser conversion tool. No data is sent to a server.</p>
        <p><span class="blink">‚òÖ</span> Copyright ¬© 2024 - All Rights Reserved <span class="blink">‚òÖ</span></p>
    </div>

<script>
// Global variables
var parsedGeometries = [];
var suggestedFilename = 'converted_data';

function updateInputPlaceholder() {
    var format = document.getElementById('inputFormat').value;
    var textarea = document.getElementById('inputData');
    
    switch(format) {
        case 'wkt':
            textarea.placeholder = 'Enter WKT data like: POINT(-122.4194 37.7749) or POLYGON((...))';
            break;
        case 'geojson':
            textarea.placeholder = 'Enter a GeoJSON object (e.g., Point, Feature, FeatureCollection). The tool will look for a "name" property for the default filename.';
            break;
        case 'latlon':
            textarea.placeholder = 'Enter coordinates like: 37.7749, -122.4194 (one or multiple lines)';
            break;
    }
}

function updateStatus(message, isError) {
    var statusContainer = document.getElementById('statusContainer');
    var statusEl = document.getElementById('statusMessage');
    
    statusEl.textContent = message;
    statusEl.className = 'status-bar ' + (isError ? 'status-error' : 'status-success');
    statusContainer.style.display = 'block';
}

// --- CORE PARSING FUNCTIONS ---

function parseWKT(wktString) {
    var geometries = [];
    var cleanedWKT = wktString.trim().toUpperCase();
    var match = cleanedWKT.match(/^(\w+)\s*\((.*)\)$/);
    if (!match) {
        updateStatus('Invalid WKT format. Ensure it starts with a geometry type.', true);
        return [];
    }
    var type = match[1];
    var content = match[2];
    try {
        switch (type) {
            case 'POINT':
                var coords = content.match(/([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)/);
                if (coords) {
                    geometries.push({ type: 'Point', coordinates: [parseFloat(coords[2]), parseFloat(coords[1])] });
                }
                break;
            case 'LINESTRING':
            case 'MULTIPOINT':
                var rawPairs = content.match(/\((\s*[+-]?\d*\.?\d+\s+[+-]?\d*\.?\d+\s*)\)|\s*([+-]?\d*\.?\d+\s+[+-]?\d*\.?\d+)\s*/g);
                var lineCoords = [];
                if (rawPairs) {
                    for (var i = 0; i < rawPairs.length; i++) {
                        var pairMatch = rawPairs[i].match(/([+-]?\d*\.?\d+)\s+([+-]?\d*\.?\d+)/);
                        if (pairMatch) {
                            lineCoords.push([parseFloat(pairMatch[2]), parseFloat(pairMatch[1])]);
                        }
                    }
                }
                if (type === 'LINESTRING') {
                    geometries.push({ type: 'LineString', coordinates: lineCoords });
                } else {
                     geometries.push({ type: 'MultiPoint', coordinates: lineCoords });
                }
                break;
            case 'POLYGON':
                var ringsMatch = content.match(/\(\s*\(([^)]*)\)\s*(?:,\s*\(([^)]*)\)\s*)?\)/);
                if (ringsMatch && ringsMatch[1]) {
                    var ringPairs = ringsMatch[1].split(',').map(function(pair) {
                        var c = pair.trim().split(/\s+/);
                        return [parseFloat(c[1]), parseFloat(c[0])];
                    });
                    geometries.push({ type: 'Polygon', coordinates: [ringPairs] });
                }
                break;
            case 'MULTILINESTRING':
            case 'MULTIPOLYGON':
                var outerParens = content.match(/\(([^()]+(?:\([^()]*\)[^()]*)*)\)/g);
                if (outerParens) {
                    var multiGeomCoords = [];
                    for (var i = 0; i < outerParens.length; i++) {
                        var currentContent = outerParens[i].replace(/^\(|\)$/g, ''); 
                        if (type === 'MULTIPOLYGON') {
                            var innerRingsMatch = currentContent.match(/\(([^)]*)\)/g);
                            if (innerRingsMatch) {
                                var polygonRings = [];
                                for (var k = 0; k < innerRingsMatch.length; k++) {
                                    var ringData = innerRingsMatch[k].replace(/^\(|\)$/g, '');
                                    var ringCoords = ringData.split(',').map(function(pair) {
                                        var c = pair.trim().split(/\s+/);
                                        return [parseFloat(c[1]), parseFloat(c[0])];
                                    });
                                    polygonRings.push(ringCoords);
                                }
                                if (polygonRings.length > 0) {
                                     multiGeomCoords.push(polygonRings);
                                }
                            }
                        } else {
                            var lineCoords = [];
                            var pairs = currentContent.split(',');
                            for (var j = 0; j < pairs.length; j++) {
                                var pair = pairs[j].trim().split(/\s+/);
                                if (pair.length >= 2) {
                                    lineCoords.push([parseFloat(pair[1]), parseFloat(pair[0])]);
                                }
                            }
                            if (lineCoords.length > 0) {
                                multiGeomCoords.push(lineCoords);
                            }
                        }
                    }
                    if (multiGeomCoords.length > 0) {
                         geometries.push({ type: type, coordinates: multiGeomCoords });
                    }
                }
                break;
            case 'GEOMETRYCOLLECTION':
                updateStatus('Warning: GeometryCollection WKT parsing is limited and may not capture all sub-geometries correctly.', false);
                var geomStrings = content.match(/(\w+\s*\(.*?\)(?=\s*,\s*\w+\s*\(.*?\))|.*)/g);
                if (geomStrings) {
                    for (var i = 0; i < geomStrings.length; i++) {
                        geometries = geometries.concat(parseWKT(geomStrings[i].trim()));
                    }
                }
                break;
            default:
                updateStatus('Unsupported WKT geometry type: ' + type, true);
        }
    } catch (e) {
        updateStatus('Error parsing WKT: ' + e.message, true);
        return [];
    }
    return geometries;
}

function extractGeometriesFromGeoJSON(geojsonObj) {
    var geometries = [];
    if (!geojsonObj || typeof geojsonObj !== 'object') return geometries;

    var swapCoords = function(coords) { return [coords[1], coords[0]]; };
    var processCoords = function(arr, level) {
        if (level === 1) return arr.map(swapCoords);
        if (level > 1) return arr.map(function(subArr) { return processCoords(subArr, level - 1); });
        return [];
    };

    switch (geojsonObj.type) {
        case 'FeatureCollection':
            if (geojsonObj.features) geojsonObj.features.forEach(function(f) { geometries = geometries.concat(extractGeometriesFromGeoJSON(f)); });
            break;
        case 'Feature':
            if (geojsonObj.geometry) geometries = geometries.concat(extractGeometriesFromGeoJSON(geojsonObj.geometry));
            break;
        case 'GeometryCollection':
            if (geojsonObj.geometries) geojsonObj.geometries.forEach(function(g) { geometries = geometries.concat(extractGeometriesFromGeoJSON(g)); });
            break;
        case 'Point':
            if (geojsonObj.coordinates) geometries.push({ type: 'Point', coordinates: swapCoords(geojsonObj.coordinates) });
            break;
        case 'MultiPoint':
        case 'LineString':
            if (geojsonObj.coordinates) geometries.push({ type: geojsonObj.type, coordinates: processCoords(geojsonObj.coordinates, 1) });
            break;
        case 'MultiLineString':
        case 'Polygon':
            if (geojsonObj.coordinates) geometries.push({ type: geojsonObj.type, coordinates: processCoords(geojsonObj.coordinates, 2) });
            break;
        case 'MultiPolygon':
            if (geojsonObj.coordinates) geometries.push({ type: 'MultiPolygon', coordinates: processCoords(geojsonObj.coordinates, 3) });
            break;
    }
    return geometries;
}

function parseGeoJSON(geojsonString) {
    try {
        var geojson = JSON.parse(geojsonString);
        return extractGeometriesFromGeoJSON(geojson);
    } catch (e) {
        updateStatus('Invalid GeoJSON format: ' + e.message, true);
        return [];
    }
}

function parseLatLon(latlonString) {
    var geometries = [];
    var lines = latlonString.split('\n');
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i].trim();
        if (!line) continue;
        var match = line.match(/^(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)$/) || line.match(/lat[itude]*:\s*(-?\d+\.?\d*)\s*,?\s*lon[gitude]*:\s*(-?\d+\.?\d*)/i);
        if (match) {
            var lat = parseFloat(match[1]);
            var lon = parseFloat(match[2]);
            if (!isNaN(lat) && !isNaN(lon)) {
                geometries.push({ type: 'Point', coordinates: [lat, lon] });
            }
        }
    }
    return geometries;
}

// --- CORE OUTPUT FUNCTIONS ---

function coordsToWKT(geoms) {
    if (geoms.length === 0) return '';
    var wktParts = [];
    var coordToWKTPoint = function(c) { return c[1] + ' ' + c[0]; };
    var processCoords = function(arr, level) {
        if (level === 1) return arr.map(coordToWKTPoint).join(', ');
        if (level > 1) return arr.map(function(subArr) { return '(' + processCoords(subArr, level - 1) + ')'; }).join(', ');
        return '';
    };

    for (var i = 0; i < geoms.length; i++) {
        var geom = geoms[i];
        if (!geom) continue;
        var part;
        switch (geom.type.toUpperCase()) {
            case 'POINT':           part = 'POINT(' + coordToWKTPoint(geom.coordinates) + ')'; break;
            case 'MULTIPOINT':      part = 'MULTIPOINT(' + processCoords(geom.coordinates, 1) + ')'; break;
            case 'LINESTRING':      part = 'LINESTRING(' + processCoords(geom.coordinates, 1) + ')'; break;
            case 'POLYGON':         part = 'POLYGON(' + processCoords(geom.coordinates, 2) + ')'; break;
            case 'MULTILINESTRING': part = 'MULTILINESTRING(' + processCoords(geom.coordinates, 2) + ')'; break;
            case 'MULTIPOLYGON':    part = 'MULTIPOLYGON(' + processCoords(geom.coordinates, 3) + ')'; break;
            default: continue;
        }
        wktParts.push(part);
    }
    if (wktParts.length === 1) return wktParts[0];
    return 'GEOMETRYCOLLECTION(' + wktParts.join(', ') + ')';
}

function coordsToGeoJSON(geoms) {
    if (geoms.length === 0) return '';
    var geojsonGeometries = [];
    var swapCoords = function(c) { return [c[1], c[0]]; };
    var processCoords = function(arr, level) {
        if (level === 1) return arr.map(swapCoords);
        if (level > 1) return arr.map(function(subArr) { return processCoords(subArr, level - 1); });
        return [];
    };

    for (var i = 0; i < geoms.length; i++) {
        var geom = geoms[i];
        if (!geom) continue;
        var outGeom = { type: geom.type };
        switch (geom.type) {
            case 'Point':           outGeom.coordinates = swapCoords(geom.coordinates); break;
            case 'MultiPoint':
            case 'LineString':      outGeom.coordinates = processCoords(geom.coordinates, 1); break;
            case 'MultiLineString':
            case 'Polygon':         outGeom.coordinates = processCoords(geom.coordinates, 2); break;
            case 'MultiPolygon':    outGeom.coordinates = processCoords(geom.coordinates, 3); break;
            default: continue;
        }
        geojsonGeometries.push(outGeom);
    }

    var result;
    if (geojsonGeometries.length === 1) {
        result = { "type": "Feature", "geometry": geojsonGeometries[0], "properties": {} };
    } else {
        result = { "type": "FeatureCollection", "features": geojsonGeometries.map(function(g) {
            return { "type": "Feature", "geometry": g, "properties": {} };
        })};
    }
    return JSON.stringify(result, null, 2);
}

function coordsToLatLon(geoms) {
    if (geoms.length === 0) return '';
    var flatCoords = [];
    function flattenRecursive(coordsArray) {
        if (!coordsArray) return;
        if (typeof coordsArray[0] === 'number') {
            flatCoords.push(coordsArray[0] + ', ' + coordsArray[1]);
        } else if (Array.isArray(coordsArray[0])) {
            for (var i = 0; i < coordsArray.length; i++) {
                flattenRecursive(coordsArray[i]);
            }
        }
    }
    for (var i = 0; i < geoms.length; i++) {
        if (geoms[i] && geoms[i].coordinates) {
            flattenRecursive(geoms[i].coordinates);
        }
    }
    var uniqueCoords = [];
    var seen = {};
    for (var j = 0; j < flatCoords.length; j++) {
        if (!seen[flatCoords[j]]) {
            uniqueCoords.push(flatCoords[j]);
            seen[flatCoords[j]] = true;
        }
    }
    return uniqueCoords.join('\n');
}

// --- MAIN CONVERSION LOGIC ---

function convertData() {
    var inputFormat = document.getElementById('inputFormat').value;
    var outputFormat = document.getElementById('outputFormat').value;
    var inputData = document.getElementById('inputData').value.trim();
    var outputEl = document.getElementById('outputData');
    var downloadBtn = document.getElementById('downloadButton');
    
    outputEl.value = '';
    downloadBtn.disabled = true;
    parsedGeometries = [];
    suggestedFilename = 'converted_data';

    if (!inputData) {
        updateStatus('Please enter data to convert.', true);
        return;
    }
    
    // Extract filename from GeoJSON with better UTF-8 handling
    if (inputFormat === 'geojson') {
        try {
            var geojson = JSON.parse(inputData);
            var extractName = function(obj) {
                if (obj && typeof obj === 'object') {
                    if (obj.properties && obj.properties.name) {
                        return obj.properties.name;
                    }
                    if (obj.name) {
                        return obj.name;
                    }
                    if (obj.features && Array.isArray(obj.features) && obj.features.length > 0) {
                        return extractName(obj.features[0]);
                    }
                }
                return null;
            };
            
            var extractedName = extractName(geojson);
            if (extractedName) {
                // Properly handle UTF-8 characters and sanitize filename
                suggestedFilename = extractedName
                    .replace(/[<>:"/\\|?*]/g, '_')  // Replace invalid filename characters
                    .replace(/\s+/g, '_')           // Replace spaces with underscores
                    .substring(0, 100);             // Limit length
            }
        } catch (e) {
            // If parsing fails for name extraction, continue with default
        }
    }
    
    switch(inputFormat) {
        case 'wkt':     parsedGeometries = parseWKT(inputData); break;
        case 'geojson': parsedGeometries = parseGeoJSON(inputData); break;
        case 'latlon':  parsedGeometries = parseLatLon(inputData); break;
    }
    
    if (parsedGeometries.length === 0) {
        updateStatus('Could not parse valid data from your input. Please check the format and try again.', true);
        return;
    }
    
    var output = '';
    switch(outputFormat) {
        case 'wkt':     output = coordsToWKT(parsedGeometries); break;
        case 'geojson': output = coordsToGeoJSON(parsedGeometries); break;
        case 'latlon':  output = coordsToLatLon(parsedGeometries); break;
    }
    
    outputEl.value = output;
    if (output) {
        downloadBtn.disabled = false;
        updateStatus('Conversion successful! Processed ' + parsedGeometries.length + ' geometry object(s).', false);
    }
}

function copyResults() {
    var outputEl = document.getElementById('outputData');
    if (!outputEl.value) {
        updateStatus('There is nothing to copy.', true);
        return;
    }
    navigator.clipboard.writeText(outputEl.value).then(function() {
        updateStatus('Results copied to clipboard!', false);
    }, function() {
        updateStatus('Failed to copy. Your browser might not support this feature.', true);
    });
}

function downloadFile() {
    var outputText = document.getElementById('outputData').value;
    if (!outputText) {
        updateStatus('There is no data to download.', true);
        return;
    }

    var filename = prompt("Enter a filename (without extension):", suggestedFilename);
    if (!filename) {
        updateStatus("Download cancelled.", false);
        return;
    }

    var outputFormat = document.getElementById('outputFormat').value;
    var extension = 'txt';
    var mimeType = 'text/plain';

    if (outputFormat === 'geojson') {
        extension = 'geojson';
        mimeType = 'application/geo+json';
    } else if (outputFormat === 'wkt') {
        extension = 'wkt';
        mimeType = 'text/plain';
    }
    
    var finalFilename = filename + '.' + extension;

    // Create blob with explicit UTF-8 encoding
    var blob = new Blob(['\ufeff' + outputText], { 
        type: mimeType + ';charset=utf-8;' 
    });
    
    // Create download link
    var link = document.createElement("a");
    var url = URL.createObjectURL(blob);
    link.setAttribute("href", url);
    link.setAttribute("download", finalFilename);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Clean up the URL object
    setTimeout(function() {
        URL.revokeObjectURL(url);
    }, 100);

    updateStatus("File '" + finalFilename + "' download initiated with UTF-8 encoding.", false);
}

// Initialize placeholder text on page load
updateInputPlaceholder();
</script>

</body>
</html>
